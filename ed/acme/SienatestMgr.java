/******************************************************************
 * Sienatest Gauge Manager Implementation
 * Generated by gaugeSpecifier.SpecifierGUI
 *****************************************************************/
package gauges.Siena;
import java.util.*;
import java.io.*;
import edu.cmu.cs.able.gaugeInfrastructure.*;
import edu.cmu.cs.able.gaugeInfrastructure.Events.*;
import edu.cmu.cs.able.gaugeInfrastructure.util.*;
import edu.cmu.cs.able.gaugeInfrastructure.Siena.*;
/** This is the implementation of a gauge manager for the Sienatest.
 * It starts a separate process for the gauge using the Java Runtime
 * exec method, and then optionally tracks and prints the output from
 * the stdout and stderr of the gauge.
 *
 */
public class SienatestMgr extends edu.cmu.cs.able.gaugeInfrastructure.Siena.SienaGaugeMgr implements Runnable {
  
  private Hashtable p2out = new Hashtable(); // Process -> Thread
  private Hashtable out2p = new Hashtable(); // Thread -> Process
  private Hashtable threadState = new Hashtable();  // Thread -> String
  public String senp = "";
  private final String gaugeClassPackage = "gauges.Siena.Siena";
  private static Vector gaugeTypes = new Vector();
  static {
    initializeGaugeTypes();
  }
  
  
  private static boolean trackGaugeOutput = true;
  
  private GaugeReportingBus reportingBus = new SienaGaugeReportingBus();
  
  /** Creates new SienatestMgr
   * @param senp The Siena port to connect to to receive information
   * from gauge consumers and gauges.
   * @param register Indicates whether the gauge manager should be registed with the bus.
   */
  public SienatestMgr(String senp, boolean register) {
    super();
    this.senp = senp;
    if (register)
      ((SienaGaugeReportingBus )reportingBus).sienaBus.registerGaugeMgr(this);
  }
  
  /** Creates a new gauge as a separate process.
   * @param gauge The ID of the gauge to create.
   * @param setupParams The setup parameters to pass to the new gauge.
   * @param mappings The mappings to pass to the new gauge.
   * @return A "dummy" gauge control that has the new ID.
   */
  public GaugeControl createGauge(GaugeID gauge, StringPairVector setupParams, StringPairVector mappings) {
    
    if (managesType(gauge.gaugeType)) {
      
      // make mappings string
      int i;
      String strMappings = "";
      for (i = 0; i < mappings.size(); i++) {
        strMappings += mappings.nameAt(i) + "=" + mappings.valueAt(i) + " ";
      }
      
      String strSetup = "";
      for (i = 0; i < setupParams.size(); i++) {
        strSetup += setupParams.nameAt(i) + "=" + setupParams.valueAt(i) + " ";
      }
      
      SienaGaugeMgrGaugeHandle gaugeHandle = new SienaGaugeMgrGaugeHandle(gauge);
      String args = " -mn " + gauge.modelName + " -mt " + gauge.modelType +
      " -gt " + gauge.gaugeType + " -gn " + gauge.gaugeName +
      " -creator \"" + getGaugeMgrID() + "\" -senp " + senp +
      " -setup " + strSetup + " -mappings " + strMappings;
      
      if (edu.cmu.cs.able.gaugeInfrastructure.util.Global.debugFlag) {
        args += " -debug";
      }
      try {
        // Start the gauge process
        System.out.println("Creating " + gaugeType + args);
        Process gaugeProcess = Runtime.getRuntime().exec("java " + gaugeClassPackage + gaugeType + args);
        
        // Only start the output thread if gauges are being tracked
        if (trackGaugeOutput) {
          Thread gaugeInOutput = new Thread(this, "IN" + gauge.toString());
          Thread gaugeErrOutput = new Thread(this, "ER" + gauge.toString());
          p2out.put(gaugeProcess.toString() + "IN", gaugeInOutput);
          p2out.put(gaugeProcess.toString() + "ERR", gaugeErrOutput);
          out2p.put(gaugeInOutput, gaugeProcess);
          out2p.put(gaugeErrOutput, gaugeProcess);
          gaugeInOutput.start();
          gaugeErrOutput.start();
        }
        return gaugeHandle;
      }
      catch (IOException ex) {
        System.err.println("Could not create gauge");
        ex.printStackTrace();
        return null;
      }
    }
    return null;
  }
  
  /** Deletes the gauge process associated with the gauge ID.
   * @param gauge The gauge to be deleted.
   * @return Whether the process was destroyed successfully.
   */
  public boolean deleteGauge(GaugeControl gauge) {
    Process gaugeProcess = (Process )gauges.get(gauge.getGaugeID());
    if (gaugeProcess != null) {
      // Stop tracking gauge output
      if (trackGaugeOutput) {
        Thread output1Thread = (Thread )p2out.get(gaugeProcess.toString() + "IN");
        Thread output2Thread = (Thread )p2out.get(gaugeProcess.toString() + "ERR");
        // This may not make a gauge announce a delete event -- put it in the finalize of the gauge?
        threadState.put(output1Thread, "stop");
        threadState.put(output2Thread, "stop");
      }
      
      // Delete the gauge process
      try {
        gaugeProcess.destroy();
      }
      catch (Throwable t) {
        System.err.println("Could not destroy gauge");
        t.printStackTrace();
        return false;
      }
      DeletedEvent event = new DeletedEvent(gauge.getGaugeID());
      event.gaugeMgrID = getGaugeMgrID();
      event.status = true;
      reportingBus.reportDeleted(event);
    }
    return true;
  }
  
  /** Returns true if the gauge type is gauges.Siena.Sienatest
   * @param gaugeType
   * @return
   */
  public boolean managesType(String gaugeType) {
    return gaugeTypes.contains(gaugeType);
  }
  
  /** Returns the parameters that can be used to configure the gauge,
   * as well as the values reported by the gauge, for a particular
   * gauge type.
   * @param gaugeType The type of the gauge about which to get information.
   * @param configParamsMeta
   * @param valuesMeta
   * @return
   */
  public boolean queryMetaInfo(String gaugeType, StringPairVector configParamsMeta, StringPairVector valuesMeta) {
    if (managesType(gaugeType)) {
      int index = gaugeTypes.indexOf(gaugeType);
      switch (index) {
        case 0:
          configParamsMeta.addElement("ReportingFrequency", "Int");
          valuesMeta.addElement("Load", "Float");
          break;
          
      }
      return true;
    }
    else {
      return false;
    }
  }
  
  /** Implements the run method for threads. This method (if gauge stderr and stdin are being tracked)
   * will periodically output the values to stdout of the gauge manager.
   */
  public void run() {
    
    Thread myThread = Thread.currentThread();
    // Get the gauge process associated with this thread
    Process gaugeProcess = (Process )out2p.get(myThread);
    
    if (gaugeProcess != null) {
      BufferedReader in = null;
      // Create a new input channel depending on whether I'm the IN thread or the ERR thread
      if (myThread.getName().substring(0,2).equals("IN")) {
        in = new BufferedReader(new InputStreamReader(gaugeProcess.getInputStream()));
      }
      else {
        in = new BufferedReader(new InputStreamReader(gaugeProcess.getErrorStream()));
      }
      
      // if I'm still running, output any info I get from the gauge process
      while (threadState.get(myThread) == null) {
        try {
          String n = in.readLine();
          while (n != null) {
            System.out.println(myThread.getName() + "==>" + n);
            n = in.readLine();
          }
        }
        catch (IOException e) {
          
        }
        catch (Exception e) {}
        
        // Sleep for a second
        try {
          Thread.sleep(1000);
        }
        catch (Exception e) {
        }
      }
      
    }
  }
  
  /** A way to start the gauge manager from the command line.
   * @param args -senp <i>siena port</i><br>
   * [-debug] [-silent]<br>
   *
   * -debug indicates whether debugging information should be displayed<br>
   * -silent indicates whether the gauge outputs should be tracked.
   *
   */
  public static void main(String[] args) {
    
    String senp = "";
    boolean setup = false;
    for (int i = 0; i < args.length; i++) {
      
      if (args [i].equals("-senp")) {
        senp = args [++i];
        edu.cmu.cs.able.gaugeInfrastructure.Siena.Initialization.initSiena(senp);
        setup = true;
      }
      else if (args [i].equals("-debug")) {
        edu.cmu.cs.able.gaugeInfrastructure.util.Global.debugFlag = true;
      }
      else if (args [i].equals("-silent")) {
        trackGaugeOutput = false;
      }
      else {
        printUsageMessage();
        System.exit(0);
      }
    }
    
    if (!setup) {
      printUsageMessage();
      System.exit(0);
    }
    
    SienatestMgr gm = new SienatestMgr(senp, true);
    
    while (true) {
      try {
        Thread.sleep(100000000);
      }
      catch (Exception e) {
      }
    }
  }
  
  /** Prints the usag?e message.
   */
  public static void printUsageMessage() {
    System.err.println("Usage: SienatestMgr -senp <siena-port> [-debug] [-silent]");
    
  }
  
  private static void initializeGaugeTypes() {
    gaugeTypes.add("NounLoadT");
    
  }
}
